# ---------------------------------------------------------------------------
# GatherLib (Tier-Only System)
# ---------------------------------------------------------------------------
using(
  baglib="5f1ffcbf-3f59-4396-b402-1ca0f02d6bbb"
)

# -----------------------------
# Text Helpers
# -----------------------------
def q(s):
  return (s or "").replace("\"", "'")

def title_words(s, default=""):
  s = (s or "").strip()
  if not s:
    return default
  out = []
  for part in s.split(" "):
    part = part.strip()
    if not part:
      continue
    if len(part) == 1:
      out.append(part.upper())
    else:
      out.append(part[0].upper() + part[1:].lower())
  return " ".join(out) if out else (default or s)

# -----------------------------
# Embed Builder
# -----------------------------
def build_output(
  title,
  desc_lines=None,
  fields=None,
  footer=None,
  thumb_url=None,
  time=None,
  color=0x2ecc71,
  ch=character()
):
  if thumb_url is None:
    thumb_url = ch.image

  desc = "\n".join(desc_lines or [])
  out = [
    f'-title "{q(title)}"',
    f'-desc "{q(desc)}"',
    f'-color {color}'
  ]

  if footer:
    out.append(f'-footer "{q(footer)}"')

  if thumb_url:
    out.append(f'-thumb "{thumb_url}"')

  if time is not None:
    out.append(f'-t {int(time)}')

  for n, v in (fields or []):
    if v:
      out.append(f'-f "{q(n)}|{q(v)}"')

  return " ".join(out)

# -----------------------------
# Tier Selection
# -----------------------------
def resolve_tier(cmd, tier_aliases=None):
  cmd = (cmd or "").lower().strip()
  tier_aliases = tier_aliases or {}
  return (tier_aliases.get(cmd, cmd) or "").lower().strip()

def pick_weighted_label(weight_map, default_label="common"):
  if not weight_map:
    return default_label

  labels = []
  weights = []

  for lbl, w in weight_map.items():
    lbl = (lbl or "").strip().lower()
    try:
      w = int(w)
    except:
      continue
    if lbl and w > 0:
      labels.append(lbl)
      weights.append(w)

  if not labels:
    return default_label

  return randchoices(labels, weights=weights)[0]

def select_tier(data, cmd=None):
  tiers = data.get("tiers", {}) or {}
  cfg = data.get("config", {}) or {}
  tier_aliases = data.get("tier_aliases", {}) or {}

  # Enabled tiers only
  enabled = {}
  for k, v in tiers.items():
    if (v or {}).get("enabled", True):
      enabled[k] = v

  default_tier = (cfg.get("default_tier") or "common").lower()
  if default_tier not in enabled and enabled:
    default_tier = list(enabled.keys())[0]

  weights = cfg.get("tier_weights") or {}

  resolved = resolve_tier(cmd, tier_aliases)
  if resolved and resolved in enabled:
    tier = resolved
  else:
    filt_weights = {k: v for k, v in weights.items() if k in enabled}
    tier = pick_weighted_label(filt_weights, default_label=default_tier)
    if tier not in enabled:
      tier = default_tier

  dc_val = int((enabled.get(tier) or {}).get("dc", 10))
  tier_label = (enabled.get(tier) or {}).get("label") or title_words(tier, tier)

  return {
    "tier": tier,
    "tier_label": tier_label,
    "dc_val": dc_val
  }

# -----------------------------
# Skill Resolver
# -----------------------------
def resolve_skill_or_none(ch, skill_name):
  name = (skill_name or "").strip().lower().replace(" ", "")
  return getattr(ch.skills, name, None)

# -----------------------------
# Checks
# -----------------------------
def build_check_expr(skill_obj, adv=False, dis=False, guidance=False):
  if adv and not dis:
    expr = skill_obj.d20(base_adv=True)
  elif dis and not adv:
    expr = skill_obj.d20(base_adv=False)
  else:
    expr = skill_obj.d20()

  if guidance:
    expr += "+1d4[guidance]"
  return expr

def roll_check(ch, skill, dc, adv=False, dis=False, guidance=False):
  s = resolve_skill_or_none(ch, skill)
  if not s:
    return {"roll": None, "ok": False}

  expr = build_check_expr(s, adv, dis, guidance)
  r = vroll(expr)

  return {
    "roll": r,
    "ok": r.total >= int(dc)
  }

# -----------------------------
# Rewards
# -----------------------------
def calc_reward_points(extracted, adv=False, dis=False, prof=False, exp=False, base_label="Tool"):
  if not extracted:
    return {"points": 0, "lines": ["> No resources gained."]}

  pts = 1
  lines = [f"> 1 for {base_label}"]

  if adv and not dis:
    pts += 1
    lines.append("> +1 for Advantage")

  if prof:
    pts += 1
    lines.append("> +1 for Proficiency")

  if exp:
    pts += 1
    lines.append("> +1 for Expertise")

  return {"points": pts, "lines": lines}

# -----------------------------
# Bag Helpers
# -----------------------------
def ensure_activity_bag(ch, activity, bag_label, bag_cvar):
  mgr = baglib.LoadedBags(ch=ch, cvar=bag_cvar)
  bag = mgr.get_bag(bag_label) or mgr.new_bag(bag_label)
  return mgr, bag[0]

def add_rewards_to_bag(ch, activity, bag_label, bag_cvar, rewards):
  mgr, bag_name = ensure_activity_bag(ch, activity, bag_label, bag_cvar)
  for item, qty in rewards.items():
    mgr.modify_item(item=item, quantity=int(qty), bag_name=bag_name, create_on_fail=False)
  mgr.save_bags()
  return bag_name